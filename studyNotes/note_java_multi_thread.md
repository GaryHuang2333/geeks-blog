并发多线程与分布式架构
1. 并发与多线程
1.1. 概念解析
1.1.1. 进程 VS 线程 :
进程 Process : (没啥好解释的)
	[eg : 一个迅雷程序就是一个进程]
线程 Thread : 进程 包含 n x 线程(n>=1). 同一个进程内, 多个线程共享内存空间(线程栈)
	[eg : 一个迅雷程序有多个下载任务, 每个任务都是一个线程]

1.1.2. 并发 VS 并行
并发 Concurrency : 宏观上看, 多个线程"同时"执行; 微观上看, 一个CPU每次只能执行一个线程, 多个线程按照序列轮流执行, 线程间存在竞争关系.
	[eg: 宏观 - 迅雷能同时下载多个任务]
并行 Parallelism : 宏观微观一致, 多个CPU同时执行多个线程, 线程之间没有竞争关系. 
	[eg: 多核CPU]

1.1.3. 串行 VS 并行	
串行 : 多个任务按顺序执行, 一个接一个
并行 : 多个任务同时执行

1.1.4. 同步 VS 异步 (能否开启新线程)
同步 : 不能. 顺序执行, 执行完一个再执行下一个, 需要等待, 协调运行.
异步 : 能. 多线程是实现异步的一种方式

1.2. 线程的状态

		 ---- 阻塞状态 ----
		 |   (Blocked)   |
		 |    资源阻塞    |
		 |    睡眠阻塞    |
		 |    Wait阻塞    |
		 |    Yeild ?    |
		 |               |
新建状态	就绪状态		运行状态    死亡状态
(New)	(Runnable)  (Running)  (Dead)
	
-> 新建 : new thread()
新建 -> 就绪 : thread.start()
就绪 -> 运行 : 获取CPU时间片
运行 -> 就绪 : CPU时间片用完, 但是线程没有执行完
运行 -> 睡眠阻塞 :  Thread.sleep()
运行 -> 资源阻塞 : 请求I/O资源 / 请求同步锁资源(代码块锁/类锁/方法锁)
运行 -> wait阻塞 : Thread.wait() ?
睡眠阻塞 -> 就绪 : 睡眠时间结束
资源阻塞 -> 就绪 : I/O资源获取 / 同步锁释放, 获取同步资源 
wait阻塞 -> 就绪 : Thread.notify()
运行 -> 死亡 : 线程执行完毕 / 被终止 


1.3. 线程安全
JAVA中线程同步的方法（7种）汇总(https://www.cnblogs.com/duanxz/p/3709608.html)
Java并发编程：volatile关键字解析(https://www.cnblogs.com/dolphin0520/p/3920373.html)

内存模型 :
CPU - 高速缓存cache - 主存/物理内存memory

Java内存模型 :
线程 - 工作内存 - 主存
* 所有变量都存放在主存
* 每个线程都有自己的工作内存
* 每个线程的工作内存相互隔离
* 线程对变量的所有操作都只能在工作内存里面




